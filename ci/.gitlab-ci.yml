# =============================================================================
# QEDMMA Timestamp Capture - GitLab CI/CD Pipeline
# Auto-generated by Radar Systems Architect v9.0 - DevOps Factory Lead
# Date: 2026-01-31
#
# Pipeline Stages:
#   1. lint      - Static analysis (Verilator, SVLint, Python)
#   2. sim       - Cocotb simulation (Verilator, optionally Icarus)
#   3. synth     - FPGA synthesis (Vivado, Yosys)
#   4. timing    - Timing analysis and reports
#   5. deploy    - Bitstream packaging and artifact upload
#
# Traceability:
#   [REQ-PIPE-001] Automated build pipeline for RTL
#   [REQ-PIPE-002] Coverage-driven verification
#   [REQ-PIPE-003] Multi-target synthesis support
# =============================================================================

# -----------------------------------------------------------------------------
# Pipeline Configuration
# -----------------------------------------------------------------------------

stages:
  - lint
  - sim
  - synth
  - timing
  - package
  - deploy

variables:
  # Project paths
  RTL_DIR: "rtl"
  TB_DIR: "tb"
  SCRIPTS_DIR: "scripts"
  REGS_DIR: "regs"
  
  # Tool versions
  VERILATOR_VERSION: "5.024"
  VIVADO_VERSION: "2024.1"
  YOSYS_VERSION: "0.40"
  
  # Target device
  FPGA_PART: "xczu47dr-ffvg1517-2-e"  # Xilinx Zynq RFSoC
  FPGA_PART_YOSYS: "ice40up5k-sg48"   # For open-source flow testing
  
  # Simulation settings
  SIM_TIMEOUT: "30m"
  COVERAGE_THRESHOLD: "80"
  
  # Feature flags
  ENABLE_COVERAGE: "true"
  ENABLE_WAVEFORMS: "false"
  ENABLE_YOSYS_FLOW: "true"

# Default settings for all jobs
default:
  image: registry.gitlab.com/qedmma/fpga-ci:latest
  tags:
    - fpga
    - docker
  before_script:
    - echo "Job ${CI_JOB_NAME} started at $(date)"
    - echo "Commit: ${CI_COMMIT_SHA}"
  after_script:
    - echo "Job ${CI_JOB_NAME} finished at $(date)"

# Caching
cache:
  key: "${CI_COMMIT_REF_SLUG}"
  paths:
    - .cache/pip
    - .cache/yosys

# -----------------------------------------------------------------------------
# Stage 1: Lint
# -----------------------------------------------------------------------------

lint:verilator:
  stage: lint
  script:
    - echo "=== Verilator Lint ==="
    - |
      verilator --lint-only -Wall \
        -Wno-WIDTHEXPAND -Wno-WIDTHTRUNC -Wno-TIMESCALEMOD \
        --timing \
        -I${RTL_DIR} \
        ${RTL_DIR}/timestamp_capture_regs_pkg.sv \
        ${RTL_DIR}/timestamp_capture.sv \
        2>&1 | tee lint_verilator.log
    - |
      if grep -q "Error" lint_verilator.log; then
        echo "LINT FAILED"
        exit 1
      fi
    - echo "Verilator lint PASSED"
  artifacts:
    when: always
    paths:
      - lint_verilator.log
    expire_in: 1 week
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_BRANCH == "develop"'

lint:svlint:
  stage: lint
  script:
    - echo "=== SVLint ==="
    - |
      svlint \
        --config .svlint.toml \
        ${RTL_DIR}/*.sv \
        2>&1 | tee lint_svlint.log || true
    - echo "SVLint completed (warnings allowed)"
  artifacts:
    when: always
    paths:
      - lint_svlint.log
    expire_in: 1 week
  allow_failure: true

lint:python:
  stage: lint
  script:
    - echo "=== Python Lint (Testbench) ==="
    - pip install flake8 mypy
    - flake8 ${TB_DIR}/*.py --max-line-length=120 --ignore=E501,W503
    - mypy ${TB_DIR}/*.py --ignore-missing-imports || true
  allow_failure: true

lint:yaml-regs:
  stage: lint
  script:
    - echo "=== YAML Register Definition Lint ==="
    - pip install yamllint
    - yamllint ${REGS_DIR}/*.yaml
    - echo "Checking register address alignment..."
    - |
      python3 << 'EOF'
      import yaml
      with open('${REGS_DIR}/timestamp_capture_regs.yaml') as f:
          regs = yaml.safe_load(f)
      
      for reg in regs.get('registers', []):
          offset = reg.get('offset', 0)
          if offset % 4 != 0:
              print(f"WARNING: Register {reg['name']} not 32-bit aligned: 0x{offset:03X}")
      
      print("Register validation complete")
      EOF
  allow_failure: true

# -----------------------------------------------------------------------------
# Stage 2: Simulation
# -----------------------------------------------------------------------------

sim:verilator:
  stage: sim
  timeout: ${SIM_TIMEOUT}
  script:
    - echo "=== Cocotb Simulation (Verilator) ==="
    - pip install cocotb cocotb-bus cocotb-coverage pytest
    - cd ${TB_DIR}
    - |
      export SIM=verilator
      export WAVES=${ENABLE_WAVEFORMS}
      make clean_all || true
      make regression 2>&1 | tee ../sim_verilator.log
    - |
      # Check for failures
      if grep -q "FAILED" ../sim_verilator.log; then
        echo "SIMULATION FAILED"
        exit 1
      fi
    - echo "Verilator simulation PASSED"
  artifacts:
    when: always
    paths:
      - sim_verilator.log
      - ${TB_DIR}/results.xml
      - ${TB_DIR}/*.fst
    reports:
      junit: ${TB_DIR}/results.xml
    expire_in: 1 week
  needs:
    - lint:verilator

sim:icarus:
  stage: sim
  timeout: ${SIM_TIMEOUT}
  script:
    - echo "=== Cocotb Simulation (Icarus Verilog) ==="
    - pip install cocotb cocotb-bus
    - cd ${TB_DIR}
    - |
      export SIM=icarus
      make smoke 2>&1 | tee ../sim_icarus.log
    - echo "Icarus simulation completed"
  artifacts:
    when: always
    paths:
      - sim_icarus.log
    expire_in: 1 week
  allow_failure: true
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

sim:coverage:
  stage: sim
  timeout: ${SIM_TIMEOUT}
  script:
    - echo "=== Coverage Collection ==="
    - pip install cocotb cocotb-coverage
    - cd ${TB_DIR}
    - |
      export SIM=verilator
      export EXTRA_ARGS="--coverage"
      make regression
    - |
      # Generate coverage report
      verilator_coverage --annotate ../coverage_report sim_build/coverage.dat
    - |
      # Parse coverage percentage
      COVERAGE=$(verilator_coverage --rank sim_build/coverage.dat | grep "Total" | awk '{print $2}' | tr -d '%')
      echo "Total Coverage: ${COVERAGE}%"
      
      if [ "${COVERAGE}" -lt "${COVERAGE_THRESHOLD}" ]; then
        echo "Coverage ${COVERAGE}% below threshold ${COVERAGE_THRESHOLD}%"
        exit 1
      fi
  artifacts:
    when: always
    paths:
      - coverage_report/
      - ${TB_DIR}/sim_build/coverage.dat
    expire_in: 1 week
  needs:
    - sim:verilator
  rules:
    - if: '$ENABLE_COVERAGE == "true"'

# -----------------------------------------------------------------------------
# Stage 3: Synthesis
# -----------------------------------------------------------------------------

synth:vivado:
  stage: synth
  image: registry.gitlab.com/qedmma/vivado-ci:${VIVADO_VERSION}
  timeout: 2h
  script:
    - echo "=== Vivado Synthesis ==="
    - source /opt/Xilinx/Vivado/${VIVADO_VERSION}/settings64.sh
    - mkdir -p build/vivado
    - cd build/vivado
    - |
      # Generate Vivado TCL script
      cat > synth.tcl << 'TCEOF'
      # Vivado Synthesis Script - Auto-generated
      # [REQ-PIPE-003]
      
      set_param general.maxThreads 8
      
      # Create project
      create_project -force timestamp_capture . -part ${FPGA_PART}
      
      # Add sources
      add_files -fileset sources_1 [glob ../../${RTL_DIR}/*.sv]
      
      # Set top module
      set_property top timestamp_capture [current_fileset]
      
      # Synthesis settings
      set_property strategy Flow_PerfOptimized_high [get_runs synth_1]
      set_property STEPS.SYNTH_DESIGN.ARGS.FLATTEN_HIERARCHY rebuilt [get_runs synth_1]
      set_property STEPS.SYNTH_DESIGN.ARGS.RETIMING on [get_runs synth_1]
      
      # Run synthesis
      launch_runs synth_1 -jobs 8
      wait_on_run synth_1
      
      # Check for errors
      if {[get_property STATUS [get_runs synth_1]] != "synth_design Complete!"} {
          puts "ERROR: Synthesis failed"
          exit 1
      }
      
      # Generate reports
      open_run synth_1
      report_utilization -file utilization_synth.rpt
      report_timing_summary -file timing_synth.rpt
      report_power -file power_synth.rpt
      
      # Export checkpoint
      write_checkpoint -force timestamp_capture_synth.dcp
      
      puts "Synthesis completed successfully"
      TCEOF
    - vivado -mode batch -source synth.tcl 2>&1 | tee vivado_synth.log
  artifacts:
    when: always
    paths:
      - build/vivado/*.rpt
      - build/vivado/*.dcp
      - build/vivado/vivado_synth.log
    expire_in: 1 month
  needs:
    - lint:verilator
    - sim:verilator
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_TAG'

synth:yosys:
  stage: synth
  timeout: 30m
  script:
    - echo "=== Yosys Synthesis (Open Source Flow) ==="
    - mkdir -p build/yosys
    - cd build/yosys
    - |
      # Yosys synthesis script
      cat > synth.ys << 'YSEOF'
      # Yosys Synthesis Script - Auto-generated
      # Target: iCE40 (for open-source flow validation)
      
      # Read SystemVerilog sources
      read_verilog -sv ../../${RTL_DIR}/timestamp_capture_regs_pkg.sv
      read_verilog -sv ../../${RTL_DIR}/timestamp_capture.sv
      
      # Hierarchy check
      hierarchy -check -top timestamp_capture
      
      # High-level synthesis
      proc
      flatten
      opt -full
      
      # Technology mapping
      synth_ice40 -top timestamp_capture -json timestamp_capture.json
      
      # Reports
      stat
      
      YSEOF
    - yosys -s synth.ys 2>&1 | tee yosys_synth.log
    - |
      # Check for errors
      if grep -q "ERROR" yosys_synth.log; then
        echo "Yosys synthesis failed"
        exit 1
      fi
    - echo "Yosys synthesis PASSED"
  artifacts:
    when: always
    paths:
      - build/yosys/*.json
      - build/yosys/yosys_synth.log
    expire_in: 1 week
  needs:
    - lint:verilator
  rules:
    - if: '$ENABLE_YOSYS_FLOW == "true"'

# -----------------------------------------------------------------------------
# Stage 4: Timing Analysis
# -----------------------------------------------------------------------------

timing:vivado:
  stage: timing
  image: registry.gitlab.com/qedmma/vivado-ci:${VIVADO_VERSION}
  timeout: 3h
  script:
    - echo "=== Vivado Implementation & Timing ==="
    - source /opt/Xilinx/Vivado/${VIVADO_VERSION}/settings64.sh
    - mkdir -p build/vivado_impl
    - cd build/vivado_impl
    - |
      cat > impl.tcl << 'TCEOF'
      # Open synthesis checkpoint
      open_checkpoint ../vivado/timestamp_capture_synth.dcp
      
      # Create constraints
      create_clock -period 10.000 -name axi_clk [get_ports axi_clk]
      create_clock -period 4.000 -name ts_clk [get_ports ts_clk]
      create_clock -period 8.000 -name wr_clk [get_ports wr_clk]
      
      # Clock domain crossing
      set_clock_groups -asynchronous \
        -group [get_clocks axi_clk] \
        -group [get_clocks ts_clk]
      
      # I/O constraints (example)
      set_input_delay -clock ts_clk -max 1.0 [get_ports capture_in*]
      set_input_delay -clock ts_clk -min 0.0 [get_ports capture_in*]
      
      # Implementation
      opt_design
      place_design
      phys_opt_design
      route_design
      
      # Reports
      report_utilization -file utilization_impl.rpt
      report_timing_summary -max_paths 100 -file timing_impl.rpt
      report_power -file power_impl.rpt
      report_clock_interaction -file clock_interaction.rpt
      
      # Check timing
      set wns [get_property SLACK [get_timing_paths -max_paths 1 -nworst 1]]
      puts "Worst Negative Slack: $wns ns"
      
      if {$wns < 0} {
          puts "ERROR: Timing not met!"
          exit 1
      }
      
      # Generate bitstream
      write_bitstream -force timestamp_capture.bit
      write_debug_probes -force timestamp_capture.ltx
      
      # Export hardware
      write_hw_platform -fixed -force timestamp_capture.xsa
      
      puts "Implementation completed successfully"
      TCEOF
    - vivado -mode batch -source impl.tcl 2>&1 | tee vivado_impl.log
  artifacts:
    when: always
    paths:
      - build/vivado_impl/*.rpt
      - build/vivado_impl/*.bit
      - build/vivado_impl/*.ltx
      - build/vivado_impl/*.xsa
      - build/vivado_impl/vivado_impl.log
    expire_in: 3 months
  needs:
    - synth:vivado
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_TAG'

# -----------------------------------------------------------------------------
# Stage 5: Package
# -----------------------------------------------------------------------------

package:release:
  stage: package
  script:
    - echo "=== Packaging Release Artifacts ==="
    - mkdir -p release
    - |
      # Copy artifacts
      cp -r build/vivado_impl/*.bit release/ || true
      cp -r build/vivado_impl/*.xsa release/ || true
      cp -r ${RTL_DIR}/*.sv release/
      cp -r ${REGS_DIR}/*.yaml release/
      cp -r ${TB_DIR}/*.py release/
      
      # Generate manifest
      cat > release/MANIFEST.md << EOF
      # QEDMMA Timestamp Capture - Release Package
      
      **Version:** ${CI_COMMIT_TAG:-${CI_COMMIT_SHORT_SHA}}
      **Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
      **Commit:** ${CI_COMMIT_SHA}
      **Pipeline:** ${CI_PIPELINE_ID}
      
      ## Contents
      
      - \`timestamp_capture.bit\` - FPGA bitstream
      - \`timestamp_capture.xsa\` - Hardware platform
      - \`*.sv\` - RTL source files
      - \`*.yaml\` - Register definitions
      - \`*.py\` - Testbench files
      
      ## Build Information
      
      - Vivado Version: ${VIVADO_VERSION}
      - Target Device: ${FPGA_PART}
      
      ## Verification Status
      
      - [ ] Lint: Passed
      - [ ] Simulation: Passed
      - [ ] Synthesis: Passed
      - [ ] Timing: Met
      EOF
      
      # Create tarball
      tar -czvf timestamp_capture_${CI_COMMIT_SHORT_SHA}.tar.gz release/
  artifacts:
    paths:
      - timestamp_capture_*.tar.gz
      - release/
    expire_in: 1 year
  needs:
    - timing:vivado
  rules:
    - if: '$CI_COMMIT_TAG'

# -----------------------------------------------------------------------------
# Stage 6: Deploy
# -----------------------------------------------------------------------------

deploy:staging:
  stage: deploy
  environment:
    name: staging
    url: https://staging.qedmma.local
  script:
    - echo "=== Deploying to Staging ==="
    - |
      # Upload to artifact server
      curl -X POST \
        -H "Authorization: Bearer ${ARTIFACT_TOKEN}" \
        -F "file=@timestamp_capture_${CI_COMMIT_SHORT_SHA}.tar.gz" \
        "${ARTIFACT_SERVER}/upload/staging/"
    - echo "Deployed to staging"
  needs:
    - package:release
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  when: manual

deploy:production:
  stage: deploy
  environment:
    name: production
    url: https://prod.qedmma.local
  script:
    - echo "=== Deploying to Production ==="
    - |
      # Upload to production artifact server
      curl -X POST \
        -H "Authorization: Bearer ${ARTIFACT_TOKEN}" \
        -F "file=@timestamp_capture_${CI_COMMIT_SHORT_SHA}.tar.gz" \
        "${ARTIFACT_SERVER}/upload/production/"
    - echo "Deployed to production"
  needs:
    - deploy:staging
  rules:
    - if: '$CI_COMMIT_TAG'
  when: manual

# -----------------------------------------------------------------------------
# Utility Jobs
# -----------------------------------------------------------------------------

.generate-regs:
  stage: lint
  script:
    - echo "=== Auto-generating Register Files from YAML ==="
    - |
      python3 scripts/gen_regs.py \
        --input ${REGS_DIR}/timestamp_capture_regs.yaml \
        --output-sv ${RTL_DIR}/timestamp_capture_regs_pkg_gen.sv \
        --output-h drivers/timestamp_capture_regs.h \
        --output-py drivers/timestamp_capture_regs.py
  artifacts:
    paths:
      - ${RTL_DIR}/*_gen.sv
      - drivers/*.h
      - drivers/*.py
  when: manual

cleanup:
  stage: .post
  script:
    - echo "=== Cleaning up ==="
    - rm -rf build/ .cache/
  when: manual
