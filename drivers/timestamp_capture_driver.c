/**
 * @file timestamp_capture_driver.c
 * @brief QEDMMA Timestamp Capture Hardware Driver
 *
 * Auto-generated by Radar Systems Architect v9.0
 * Date: 2026-01-31
 *
 * This driver provides a C API for controlling the timestamp capture
 * hardware module used in QEDMMA TDOA processing.
 *
 * Traceability:
 *   [REQ-DRV-001] Provide C API for timestamp capture control
 *   [REQ-DRV-002] Support UIO and devmem access methods
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <errno.h>
#include <time.h>

#include "timestamp_capture_regs.h"

/* ============================================================================
 * Type Definitions
 * ============================================================================ */

/** Access method enumeration */
typedef enum {
    TS_ACCESS_DEVMEM,   /**< Direct /dev/mem access */
    TS_ACCESS_UIO,      /**< UIO subsystem access */
    TS_ACCESS_MOCK      /**< Mock for testing */
} ts_access_method_t;

/** Timestamp structure */
typedef struct {
    uint64_t seconds;       /**< Seconds since epoch */
    uint32_t nanoseconds;   /**< Nanoseconds within second */
    uint16_t fractional;    /**< Sub-nanosecond fraction (1/65536 ns) */
    uint8_t  channel;       /**< Capture channel */
    bool     valid;         /**< Validity flag */
} ts_timestamp_t;

/** Driver context structure */
typedef struct {
    void            *base;          /**< Mapped base address */
    size_t           map_size;      /**< Mapping size */
    int              fd;            /**< File descriptor */
    ts_access_method_t access;      /**< Access method */
    uint32_t         irq_count;     /**< IRQ counter */
    bool             initialized;   /**< Init flag */
} ts_context_t;

/** Sync source enumeration */
typedef enum {
    TS_SYNC_WHITE_RABBIT = 0,
    TS_SYNC_CSAC         = 1,
    TS_SYNC_EXTERNAL     = 2,
    TS_SYNC_FREERUN      = 3
} ts_sync_source_t;

/* ============================================================================
 * Private Macros
 * ============================================================================ */

#define TS_REG_READ(ctx, offset) \
    (*(volatile uint32_t *)((uint8_t *)(ctx)->base + (offset)))

#define TS_REG_WRITE(ctx, offset, val) \
    (*(volatile uint32_t *)((uint8_t *)(ctx)->base + (offset)) = (val))

#define TS_MAP_SIZE     0x1000  /* 4KB register space */

/* ============================================================================
 * Public API Implementation
 * ============================================================================ */

/**
 * @brief Initialize timestamp capture driver
 * 
 * @param ctx       Pointer to context structure
 * @param base_addr Physical base address of hardware
 * @param method    Access method (devmem, uio, mock)
 * @return 0 on success, negative error code on failure
 */
int ts_init(ts_context_t *ctx, uintptr_t base_addr, ts_access_method_t method)
{
    if (!ctx) {
        return -EINVAL;
    }
    
    memset(ctx, 0, sizeof(*ctx));
    ctx->access = method;
    ctx->map_size = TS_MAP_SIZE;
    
    switch (method) {
    case TS_ACCESS_DEVMEM:
        ctx->fd = open("/dev/mem", O_RDWR | O_SYNC);
        if (ctx->fd < 0) {
            perror("Failed to open /dev/mem");
            return -errno;
        }
        
        ctx->base = mmap(NULL, ctx->map_size, PROT_READ | PROT_WRITE,
                        MAP_SHARED, ctx->fd, base_addr);
        if (ctx->base == MAP_FAILED) {
            perror("mmap failed");
            close(ctx->fd);
            return -errno;
        }
        break;
        
    case TS_ACCESS_UIO:
        /* UIO device path would be /dev/uio0 or similar */
        ctx->fd = open("/dev/uio0", O_RDWR);
        if (ctx->fd < 0) {
            perror("Failed to open UIO device");
            return -errno;
        }
        
        ctx->base = mmap(NULL, ctx->map_size, PROT_READ | PROT_WRITE,
                        MAP_SHARED, ctx->fd, 0);
        if (ctx->base == MAP_FAILED) {
            perror("UIO mmap failed");
            close(ctx->fd);
            return -errno;
        }
        break;
        
    case TS_ACCESS_MOCK:
        /* Allocate mock register space for testing */
        ctx->base = calloc(1, ctx->map_size);
        if (!ctx->base) {
            return -ENOMEM;
        }
        ctx->fd = -1;
        break;
        
    default:
        return -EINVAL;
    }
    
    /* Verify hardware ID */
    uint32_t id = TS_REG_READ(ctx, TIMESTAMP_CAPTURE_ID_OFFSET);
    if (id != 0x51454454) {  /* "QEDT" */
        fprintf(stderr, "Invalid hardware ID: 0x%08X (expected 0x51454454)\n", id);
        ts_deinit(ctx);
        return -ENODEV;
    }
    
    /* Read version */
    uint32_t version = TS_REG_READ(ctx, TIMESTAMP_CAPTURE_VERSION_OFFSET);
    printf("Timestamp Capture v%d.%d.%d initialized\n",
           (version >> 16) & 0xFF, (version >> 8) & 0xFF, version & 0xFF);
    
    ctx->initialized = true;
    return 0;
}

/**
 * @brief Deinitialize driver and release resources
 * 
 * @param ctx Pointer to context structure
 */
void ts_deinit(ts_context_t *ctx)
{
    if (!ctx) return;
    
    if (ctx->base) {
        if (ctx->access == TS_ACCESS_MOCK) {
            free(ctx->base);
        } else {
            munmap(ctx->base, ctx->map_size);
        }
        ctx->base = NULL;
    }
    
    if (ctx->fd >= 0) {
        close(ctx->fd);
        ctx->fd = -1;
    }
    
    ctx->initialized = false;
}

/**
 * @brief Enable timestamp capture
 * 
 * @param ctx Pointer to context structure
 * @return 0 on success
 */
int ts_enable(ts_context_t *ctx)
{
    if (!ctx || !ctx->initialized) return -EINVAL;
    
    uint32_t ctrl = TS_REG_READ(ctx, TIMESTAMP_CAPTURE_CTRL_OFFSET);
    ctrl |= TIMESTAMP_CAPTURE_CTRL_ENABLE_MASK;
    TS_REG_WRITE(ctx, TIMESTAMP_CAPTURE_CTRL_OFFSET, ctrl);
    
    return 0;
}

/**
 * @brief Disable timestamp capture
 * 
 * @param ctx Pointer to context structure
 * @return 0 on success
 */
int ts_disable(ts_context_t *ctx)
{
    if (!ctx || !ctx->initialized) return -EINVAL;
    
    uint32_t ctrl = TS_REG_READ(ctx, TIMESTAMP_CAPTURE_CTRL_OFFSET);
    ctrl &= ~TIMESTAMP_CAPTURE_CTRL_ENABLE_MASK;
    TS_REG_WRITE(ctx, TIMESTAMP_CAPTURE_CTRL_OFFSET, ctrl);
    
    return 0;
}

/**
 * @brief Set PPS synchronization source
 * 
 * @param ctx    Pointer to context structure
 * @param source Sync source selection
 * @return 0 on success
 */
int ts_set_sync_source(ts_context_t *ctx, ts_sync_source_t source)
{
    if (!ctx || !ctx->initialized) return -EINVAL;
    if (source > TS_SYNC_FREERUN) return -EINVAL;
    
    uint32_t ctrl = TS_REG_READ(ctx, TIMESTAMP_CAPTURE_CTRL_OFFSET);
    ctrl &= ~(0x3 << 1);  /* Clear SYNC_SRC bits */
    ctrl |= ((uint32_t)source << 1);
    TS_REG_WRITE(ctx, TIMESTAMP_CAPTURE_CTRL_OFFSET, ctrl);
    
    return 0;
}

/**
 * @brief Enable specific capture channels
 * 
 * @param ctx      Pointer to context structure
 * @param channels Bitmask of channels to enable (bit 0 = CH0, etc.)
 * @return 0 on success
 */
int ts_enable_channels(ts_context_t *ctx, uint8_t channels)
{
    if (!ctx || !ctx->initialized) return -EINVAL;
    
    uint32_t ctrl = TS_REG_READ(ctx, TIMESTAMP_CAPTURE_CTRL_OFFSET);
    ctrl &= ~(0xF << 8);  /* Clear CH_EN bits */
    ctrl |= ((uint32_t)(channels & 0xF) << 8);
    TS_REG_WRITE(ctx, TIMESTAMP_CAPTURE_CTRL_OFFSET, ctrl);
    
    return 0;
}

/**
 * @brief Check if PPS is locked
 * 
 * @param ctx Pointer to context structure
 * @return true if locked, false otherwise
 */
bool ts_is_locked(ts_context_t *ctx)
{
    if (!ctx || !ctx->initialized) return false;
    
    uint32_t status = TS_REG_READ(ctx, TIMESTAMP_CAPTURE_STATUS_OFFSET);
    return (status & 0x1) != 0;
}

/**
 * @brief Check if in holdover mode
 * 
 * @param ctx Pointer to context structure
 * @return true if in holdover, false otherwise
 */
bool ts_is_holdover(ts_context_t *ctx)
{
    if (!ctx || !ctx->initialized) return false;
    
    uint32_t status = TS_REG_READ(ctx, TIMESTAMP_CAPTURE_STATUS_OFFSET);
    return (status & 0x2) != 0;
}

/**
 * @brief Read current timestamp
 * 
 * @param ctx Pointer to context structure
 * @param ts  Pointer to timestamp structure to fill
 * @return 0 on success
 */
int ts_read_current_time(ts_context_t *ctx, ts_timestamp_t *ts)
{
    if (!ctx || !ctx->initialized || !ts) return -EINVAL;
    
    /* Latch current time */
    TS_REG_WRITE(ctx, TIMESTAMP_CAPTURE_TS_LATCH_CTRL_OFFSET, 0x1);
    
    /* Small delay for latch to complete */
    usleep(1);
    
    /* Read latched values */
    uint32_t sec_lo = TS_REG_READ(ctx, TIMESTAMP_CAPTURE_TS_SEC_LO_OFFSET);
    uint32_t sec_hi = TS_REG_READ(ctx, TIMESTAMP_CAPTURE_TS_SEC_HI_OFFSET);
    uint32_t ns = TS_REG_READ(ctx, TIMESTAMP_CAPTURE_TS_NS_OFFSET);
    uint32_t frac = TS_REG_READ(ctx, TIMESTAMP_CAPTURE_TS_FRAC_OFFSET);
    
    ts->seconds = ((uint64_t)(sec_hi & 0xFFFF) << 32) | sec_lo;
    ts->nanoseconds = ns & 0x3FFFFFFF;
    ts->fractional = frac & 0xFFFF;
    ts->valid = (frac >> 31) & 0x1;
    ts->channel = 0xFF;  /* Not a channel capture */
    
    return 0;
}

/**
 * @brief Read captured timestamp from channel FIFO
 * 
 * @param ctx     Pointer to context structure
 * @param channel Channel number (0-3)
 * @param ts      Pointer to timestamp structure to fill
 * @return 0 on success, -EAGAIN if FIFO empty
 */
int ts_read_capture(ts_context_t *ctx, uint8_t channel, ts_timestamp_t *ts)
{
    if (!ctx || !ctx->initialized || !ts) return -EINVAL;
    if (channel > 3) return -EINVAL;
    
    uint32_t base_offset = TIMESTAMP_CAPTURE_CH0_CTRL_OFFSET + (channel * 0x10);
    
    /* Check FIFO status first */
    uint32_t frac = TS_REG_READ(ctx, base_offset + 0x0C);
    uint32_t fifo_count = (frac >> 16) & 0xFFF;
    
    if (fifo_count == 0) {
        return -EAGAIN;  /* FIFO empty */
    }
    
    /* Read timestamp values (reading FRAC pops from FIFO) */
    uint32_t sec = TS_REG_READ(ctx, base_offset + 0x04);
    uint32_t ns = TS_REG_READ(ctx, base_offset + 0x08);
    frac = TS_REG_READ(ctx, base_offset + 0x0C);  /* This read pops FIFO */
    
    ts->seconds = sec;  /* Only lower 32 bits for channel captures */
    ts->nanoseconds = ns & 0x3FFFFFFF;
    ts->fractional = frac & 0xFFFF;
    ts->valid = (frac >> 31) & 0x1;
    ts->channel = channel;
    
    return 0;
}

/**
 * @brief Get FIFO fill level for a channel
 * 
 * @param ctx     Pointer to context structure
 * @param channel Channel number (0-3)
 * @return FIFO count, or negative error
 */
int ts_get_fifo_count(ts_context_t *ctx, uint8_t channel)
{
    if (!ctx || !ctx->initialized) return -EINVAL;
    if (channel > 3) return -EINVAL;
    
    uint32_t base_offset = TIMESTAMP_CAPTURE_CH0_CTRL_OFFSET + (channel * 0x10);
    uint32_t frac = TS_REG_READ(ctx, base_offset + 0x0C);
    
    /* Note: This read does NOT pop the FIFO, only reading after SEC and NS does */
    return (frac >> 16) & 0xFFF;
}

/**
 * @brief Clear all FIFOs
 * 
 * @param ctx Pointer to context structure
 * @return 0 on success
 */
int ts_clear_fifos(ts_context_t *ctx)
{
    if (!ctx || !ctx->initialized) return -EINVAL;
    
    uint32_t ctrl = TS_REG_READ(ctx, TIMESTAMP_CAPTURE_CTRL_OFFSET);
    ctrl |= (1 << 16);  /* FIFO_CLR bit */
    TS_REG_WRITE(ctx, TIMESTAMP_CAPTURE_CTRL_OFFSET, ctrl);
    
    return 0;
}

/**
 * @brief Enable interrupts
 * 
 * @param ctx  Pointer to context structure
 * @param mask Interrupt enable mask
 * @return 0 on success
 */
int ts_enable_irq(ts_context_t *ctx, uint32_t mask)
{
    if (!ctx || !ctx->initialized) return -EINVAL;
    
    TS_REG_WRITE(ctx, TIMESTAMP_CAPTURE_IRQ_EN_OFFSET, mask);
    return 0;
}

/**
 * @brief Read and clear interrupt status
 * 
 * @param ctx Pointer to context structure
 * @return Interrupt status bits
 */
uint32_t ts_get_irq_status(ts_context_t *ctx)
{
    if (!ctx || !ctx->initialized) return 0;
    
    uint32_t status = TS_REG_READ(ctx, TIMESTAMP_CAPTURE_IRQ_STATUS_OFFSET);
    /* Clear by writing 1s to status bits */
    TS_REG_WRITE(ctx, TIMESTAMP_CAPTURE_IRQ_STATUS_OFFSET, status);
    
    return status;
}

/**
 * @brief Software reset
 * 
 * @param ctx Pointer to context structure
 * @return 0 on success
 */
int ts_reset(ts_context_t *ctx)
{
    if (!ctx || !ctx->initialized) return -EINVAL;
    
    uint32_t ctrl = TS_REG_READ(ctx, TIMESTAMP_CAPTURE_CTRL_OFFSET);
    ctrl |= (1U << 31);  /* SOFT_RST bit */
    TS_REG_WRITE(ctx, TIMESTAMP_CAPTURE_CTRL_OFFSET, ctrl);
    
    /* Wait for reset to complete */
    usleep(100);
    
    return 0;
}

/**
 * @brief Print current status
 * 
 * @param ctx Pointer to context structure
 */
void ts_print_status(ts_context_t *ctx)
{
    if (!ctx || !ctx->initialized) {
        printf("Driver not initialized\n");
        return;
    }
    
    uint32_t ctrl = TS_REG_READ(ctx, TIMESTAMP_CAPTURE_CTRL_OFFSET);
    uint32_t status = TS_REG_READ(ctx, TIMESTAMP_CAPTURE_STATUS_OFFSET);
    uint32_t version = TS_REG_READ(ctx, TIMESTAMP_CAPTURE_VERSION_OFFSET);
    
    printf("\n=== Timestamp Capture Status ===\n");
    printf("Version:     %d.%d.%d\n",
           (version >> 16) & 0xFF, (version >> 8) & 0xFF, version & 0xFF);
    printf("Enabled:     %s\n", (ctrl & 0x1) ? "Yes" : "No");
    printf("Sync Source: %d\n", (ctrl >> 1) & 0x3);
    printf("Channels:    0x%X\n", (ctrl >> 8) & 0xF);
    printf("PPS Locked:  %s\n", (status & 0x1) ? "Yes" : "No");
    printf("Holdover:    %s\n", (status & 0x2) ? "Yes" : "No");
    printf("PPS Count:   %d\n", (status >> 24) & 0xFF);
    printf("FIFO Empty:  0x%X\n", (status >> 8) & 0xF);
    printf("FIFO Full:   0x%X\n", (status >> 12) & 0xF);
    printf("================================\n\n");
}

/* ============================================================================
 * Example Main (for testing)
 * ============================================================================ */

#ifdef TS_DRIVER_MAIN
int main(int argc, char *argv[])
{
    ts_context_t ctx;
    ts_timestamp_t ts;
    int ret;
    
    /* Default to mock access for testing */
    ts_access_method_t method = TS_ACCESS_MOCK;
    uintptr_t base_addr = 0x80000000;
    
    if (argc > 1) {
        if (strcmp(argv[1], "devmem") == 0) {
            method = TS_ACCESS_DEVMEM;
        } else if (strcmp(argv[1], "uio") == 0) {
            method = TS_ACCESS_UIO;
        }
    }
    
    printf("Initializing timestamp capture driver...\n");
    
    ret = ts_init(&ctx, base_addr, method);
    if (ret < 0) {
        fprintf(stderr, "Failed to initialize: %d\n", ret);
        return 1;
    }
    
    /* Configure */
    ts_set_sync_source(&ctx, TS_SYNC_WHITE_RABBIT);
    ts_enable_channels(&ctx, 0xF);  /* All channels */
    ts_enable(&ctx);
    
    ts_print_status(&ctx);
    
    /* Read current time */
    ret = ts_read_current_time(&ctx, &ts);
    if (ret == 0) {
        printf("Current time: %lu.%09u s (frac: %u)\n",
               ts.seconds, ts.nanoseconds, ts.fractional);
    }
    
    /* Try reading captures */
    for (int ch = 0; ch < 4; ch++) {
        int count = ts_get_fifo_count(&ctx, ch);
        printf("Channel %d FIFO count: %d\n", ch, count);
    }
    
    ts_deinit(&ctx);
    printf("Driver deinitialized.\n");
    
    return 0;
}
#endif
